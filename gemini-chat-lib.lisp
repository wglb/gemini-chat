;;;; gemini-chat.lisp
;;;; -*- Mode: Lisp; indent-tabs-mode: nil -*-

(in-package #:gemini-chat-lib)

(declaim (optimize (speed 0) (safety 3) (debug 3) (space 0)))

;; A default tag to use if none is provided on the command line.
(defparameter *tag* "chat")

;; New special variable for the runtime output file stream
(defparameter *run-out-s* nil
  "Stream for saving conversation answers during a conversation.")

;; Log file base name for xlg-lib
(defparameter *log-file-base* "gemini-chat-log"
  "Base name for the log files generated by xlg-lib.")

;; Function to retrieve the current version
(defun get-version ()
  (slot-value (asdf:find-system 'gemini-chat-lib) 'asdf:version))

;; --- Define Flags using com.google.flag ---

(defun get-key (keyname)
  "Retrieves the Gemini API key from ~/.key/keys.lsp. If not found,
   we use the GEMINI_API_KEY environment variable.
   Signals an error if the environment variable is not set."
  (let* ((fn "~/.gemini/keys.lsp")
         (keys (if (probe-file fn)
                   (uiop:read-file-form fn)
                   nil)))
    (let* ((keyv (cond ((eq (type-of keyname) :keyword)
                        keyname)
                       (t (intern (string-upcase keyname) :keyword))))
           (key (cond (keys
                       (second (assoc keyv keys)))
                      (t (format t "getting key from environment ~%")
                         (getenv "GEMINI_API_KEY")))))
      (unless key
        (error "Error: The GEMINI_API_KEY environment variable is not set.
              Please set this before running this program."))
      key)))

(defun s-s (str delim &key (rem-empty nil))
  "Encapsulates calls to split-sequence. Splits a string by a single character delimiter.
   :rem-empty T will remove empty strings from the result list."
  (split-sequence:split-sequence delim str :remove-empty-subseqs rem-empty))

(defun s/z (str)
  (zerop (length str)))

(defun s/nz (str)
  (plusp (length str)))

;; --- Primitives for JSOWN-specific data structure creation ---

(defun make-text-part (text)
  "Creates a Lisp :OBJ representing a 'part' in the Gemini API JSON structure."
  (jsown:new-js ("text" text)))

(defun make-content-object (parts)
  "Creates a Lisp :OBJ representing 'content' in the Gemini API JSON structure."
  (jsown:new-js ("parts" parts)))

(defun make-message-turn (role content-parts)
  "Creates a Lisp :OBJ representing a single 'turn' (message) in the Gemini API JSON structure.
   This will be encoded by JSOWN as a JSON object."
  (jsown:new-js
    ("role" role)
    ("parts" content-parts)))

(defun make-api-request-payload (msgs)
  "Constructs the full JSON payload object for the Gemini API."
  (jsown:new-js ("contents" msgs)))

(defun api-req (msgs &key (model "gemini-2.5-pro"))
  "Constructs and sends an HTTP POST request to the Gemini API, 
   delegating to DO-API-REQUEST for backoff and auth. Returns the parsed JSON object."
  (let* (;; The API key is handled by the client library *static-api-key*
         (uri-parts (format nil "models/~a:generateContent" model))
         (json-payload-lisp-object (make-api-request-payload msgs))
         (json-payload-string (jsown:to-json json-payload-lisp-object)))
    (xlg :thinking-log "~&Making API request to: ~a" uri-parts :timestamp t)
    (xlg :thinking-log "JSON string being sent: ~a" json-payload-string)
    (handler-case
        (let ((result-list (do-api-request uri-parts json-payload-string :post)))
          (first result-list)) ; <-- Returns the parsed JSON object
      (error (c)
        (error "An unexpected error occurred during the API request: ~a" c)))))
    
(defun extract-txt (parsed-json)
  "Extracts the generated text from the parsed Gemini API JSON response using jsown accessors.
Returns the text string or NIL if not found."

  ;; --- START Token Count Extraction ---
  (let ((usage-metadata (jsown:val-safe parsed-json "usageMetadata")))
    (when usage-metadata
      (let ((prompt-tokens (jsown:val-safe usage-metadata "promptTokenCount"))
            (candidate-tokens (jsown:val-safe usage-metadata "candidatesTokenCount"))
            (total-tokens (jsown:val-safe usage-metadata "totalTokenCount"))
            (thoughts-tokens (jsown:val-safe usage-metadata "thoughtsTokenCount"))
            (details (jsown:val-safe usage-metadata "promptTokensDetails"))
            (model-version (jsown:val-safe parsed-json "modelVersion")))
        (let ((token-log-data (list
                               (cons :prompt-token-count (or prompt-tokens "N/A"))
                               (cons :candidates-token-count (or candidate-tokens "N/A"))
                               (cons :total-token-count (or total-tokens "N/A"))
                               (cons :thoughts-token-count (or thoughts-tokens "N/A"))
                               (cons :prompt-tokens-details (or details "N/A"))
                               (cons :modelversion (or model-version "N/A")))))
          (xlg :thinking-log "--- Token Usage (Last Response) ---~%      ~S" token-log-data)
          (xlg :token-log "~S" token-log-data)
          (xlg :thinking-log "-----------------------------------")))))
  ;; --- END Token Count Extraction ---

  (cond ((jsown:keyp parsed-json "error")
         ;; Extract detailed error info
         (let* ((the-err (jsown:val parsed-json "error"))
                (code (jsown:val-safe the-err "code"))
                (message (jsown:val-safe the-err "message"))
                (status (jsown:val-safe the-err "status")))
           
           (xlg :thinking-log "~&API Error [~a] ~a: ~a" code status message)
		   (xlgt :error-log "~&API Error [~a] ~a: ~a" code status message :timestamp t)
           (xlgt :answer-log "~&API Error [~a] ~a: ~a" code status message)
           nil))
        
        ((jsown:keyp parsed-json "candidates")
         (let* ((candidates (jsown:val parsed-json "candidates"))
                (first-candidate (car candidates)))

           ;; --- Robust Key Checking ---
           ;; Use nested IF statements and jsown:val-safe to check for the presence of the nested keys 
           ;; (content, parts, text) before attempting to access them.
           (if first-candidate
               (let ((content (jsown:val-safe first-candidate "content")))
                 (if content
                     (let ((parts (jsown:val-safe content "parts")))
                       (if parts
                           (let* ((first-part (car parts))
                                  (text (if first-part (jsown:val-safe first-part "text"))))
                             
                             (if text
                                 (progn
                                   (xlg :answer-log "~&Raw answer: ~a" text)
                                   (setf text (string-trim '(#\Space #\Tab #\Newline) text))
                                   ;;(format t "~%~a~%" text) ;; HMMM this is needed if we are interactive. TODO
                                   (if *run-out-s*
                                       (format *run-out-s* "~%~a~%" text))
                                   text)
                                 ;; Failure: Missing 'text' key
                                 (progn
                                   (xlg :thinking-log "~&Warning: Content found, but 'text' key missing in parts. JSON: ~S" parsed-json)
                                   (xlgt :error-log "~&Warning: Content found, but 'text' key missing in parts. JSON: ~S" parsed-json)
                                   nil)))
                           ;; Failure: Missing 'parts' key
                           (progn
                             (xlg :thinking-log "~&Warning: 'content' found, but 'parts' key missing. JSON: ~S" parsed-json)
                             (xlgt :error-log "~&Warning: 'content' found, but 'parts' key missing. JSON: ~S" parsed-json)
                             nil)))
                     ;; Failure: Missing 'content' key
                     (progn
                       (xlg :thinking-log "~&Warning: Candidate found, but 'content' key missing. JSON: ~S" parsed-json)
                       (xlgt :error-log "~&Warning: Candidate found, but 'content' key missing. JSON: ~S" parsed-json)
                       nil)))
               ;; Failure: Empty 'candidates' list
               (progn
                 (xlg :thinking-log "~&Warning: 'candidates' key found, but list is empty. JSON: ~S" parsed-json)
                 (xlgt :error-log "~&Warning: 'candidates' key found, but list is empty. JSON: ~S" parsed-json)
                 nil))))

        (t 
         ;; Handles the case where 'error' and 'candidates' keys are both missing (e.g., empty object or unexpected format)
         (xlg :thinking-log "~&API Response missing 'candidates' and 'error' keys. JSON: ~S" parsed-json)
         (xlgt :error-log "~&API Response missing 'candidates' and 'error' keys. JSON: ~S" parsed-json)
         nil)))

;; --- Primitives for Prompt Assembly ---

(defun assemble-context-prompt (ctx-content)
  "Assembles the context section of the prompt."
  (when (s/nz ctx-content)
    (format nil "--- Context Files --~%~a~%--- End Context Files --~%" ctx-content)))

(defun assemble-input-files-prompt (input-files exit-on-error)
  (declare (ignorable exit-on-error))
  (let ((text-segments nil)
        (blob-ids nil)
        (all-files-read-ok t))
    (dolist (file-path input-files)
      (cond 
        ;; NEW: Separate blob-ids from the text stream
        ((and (stringp file-path) (alexandria:starts-with-subseq "files/" file-path))
         (push file-path blob-ids))
        
        (t ;; Standard local file reading
         (let ((native-file-path (uiop:ensure-pathname file-path))
               (file-content nil))
           (handler-case
               (setf file-content (uiop:read-file-string native-file-path))
             (error () (setf all-files-read-ok nil)))
           (when file-content
             (push (format nil "===BEGIN_FILE: [~a]===~%~a~%===END_FILE: [~a]===" 
                           native-file-path file-content native-file-path) 
                   text-segments))))))
    ;; Return three values: The text prompt, the list of blobs, and the status
    (values (format nil "~{~a~%~%~}" (nreverse text-segments))
            all-files-read-ok
            (nreverse blob-ids))))



(defun assemble-user-prompt (prompt)
  "Formats the user's initial prompt."
  (when (s/nz prompt)
    (format nil "My prompt: ~a" prompt)))


(defun build-full-prompt (context input-files prompt-text exit-on-error)
  "Combines context, files, and task prompt. Passes blob-ids through."
  (multiple-value-bind (files-string success-p blob-ids)
      (assemble-input-files-prompt input-files exit-on-error)
    (let ((full-text 
            (if context
                (format nil "CONTEXT:~%~a~%~%FILES:~%~a~%~%TASK:~%~a" 
                        context files-string prompt-text)
                (format nil "FILES:~%~a~%~%TASK:~%~a" 
                        files-string prompt-text))))
      (values full-text success-p blob-ids))))


(defun make-file-part (file-id)
  (let ((full-uri (if (alexandria:starts-with-subseq "https://" file-id)
                      file-id
                      (format nil "https://generativelanguage.googleapis.com/v1beta/~a" file-id))))
    `(:obj ("file_data" . (:obj ("mime_type" . "text/plain")
                                ("file_uri" . ,full-uri))))))

(defun gem-conv (initial-prompt save single-shot exit-on-error &key (model "gemini-2.5-pro") (blob-ids nil))
  "Handles a turn. Now supports separate blob-ids for correct File API usage."
  (declare (ignorable exit-on-error))
  ;; Construct parts: Start with the text, then add each blob as a file part
  (let* ((parts (append (list (make-text-part initial-prompt))
                        (mapcar #'make-file-part blob-ids)))
         (conversation-history (list (make-message-turn "user" parts))))
	;;(break "blob-ids ~s" blob-ids)
    (loop
      (let* ((parsed-json (api-req conversation-history :model model)))
        (when save
          (save-cmd (format nil ":save ~a" save)))
        (let ((answer (extract-txt parsed-json)))
          (when (jsown:keyp parsed-json "candidates")
            (push (make-message-turn "model" (list (make-text-part answer))) conversation-history))
          (unless (or (string= answer "quit") (string= answer ":quit") single-shot)
            (format t "~&Single shot is ~s>> " single-shot)
            (finish-output)
            (let ((user-input (read-line)))
              (when (or (string= user-input "quit") (string= user-input ":quit"))
                (return))
              (let ((command (if (s/nz user-input)
                                 (string-trim '(#\Space #\Tab)
                                              (car (s-s user-input #\Space :rem-empty nil)))
                                 "")))
                (cond
                  ((string= command ":input") (input-cmd user-input))
                  ((string= command ":save") (save-cmd user-input)) 
                  (t
                   (push (make-message-turn "user" (list (make-text-part user-input))) 
                         conversation-history)))))))
        (when single-shot (return))))))

(defun save-cmd (out-to-user &key (if-exists :supersede))
  "Handles the :save command, opening a new file for responses."
  (let* ((args (s-s out-to-user #\Space :rem-empty t))
         (file-path (second args)))
    (when (s/z file-path)
      (format t "~&Please specify a file to save to, e.g., :save my-session.log~%")
      (return-from save-cmd))
    (when *run-out-s*
      (format t "~&gchat: save-cmd: Closing previous save file: ~a~%" (file-namestring (pathname *run-out-s*)))
      (close *run-out-s*)
      (setf *run-out-s* nil))
    (handler-case
        (let ((actual-path (uiop:ensure-pathname (if (uiop:absolute-pathname-p file-path)
                                                     file-path
                                                     (uiop:merge-pathnames* file-path (uiop:getcwd))))))
          #+nil (break "actual-path ~s ~s" actual-path file-path)
          (xlg :thinking-log "~&Opening save file: ~a" actual-path)
          (setf *run-out-s* (open actual-path :direction :output :if-does-not-exist :create :if-exists if-exists))
          (xlgt :thinking-log "~&gchat: save-cmd: Now saving responses to: " actual-path))
      (error (c)
        (xlgt :error-log "~s~&gchat: save-cmd: Failed to open file for saving: ~a" c)
        (setf *run-out-s* nil)))))

(defun input-cmd (user-input)
  "Handles the :input command. Currently just logs the intention."
  (let* ((args (s-s user-input #\Space :rem-empty t))
         (files (second args)))
    (when (s/z files)
      (format t "~&Please specify input files, e.g., :input file1.txt,file2.lisp~%")
      (return-from input-cmd))
    (format t "~&[Note: Input files functionality is part of the initial prompt only in this version. Files will be included in the next request, but not in interactive mode as of yet]~%")))

(defun get-default-context-file ()
  "Returns the path to the default context file if it exists."
  (let ((default-path (uiop:merge-pathnames* "gemini-chat-context.md" (uiop:getcwd))))
    (if (uiop:file-exists-p default-path)
        default-path
        nil)))

(defun proc-ctx-files (file-list)
  "Processes a list of context files and returns a single string of their combined content."
  (when file-list
    (let ((result (make-string-output-stream)))
      (dolist (file file-list)
        (handler-case
            (format result "~&File: ~a~%```~%~a~%```~%~%" (file-namestring file) (uiop:read-file-string file))
          (error (e)
            (xlg :error-log "~&Failed to read context file: ~a" e)
            (format t "~&Failed to read context file: ~a~%" e))))
      (get-output-stream-string result))))


(defvar *batch-output-stream* nil 
  "Global stream for the 1.5M request JSONL export.")

(defun write-batch-jsonl-line (prompt-text model output-path)
  "Writes a Google-compliant JSONL line to the open *batch-output-stream*.
   Uses the absolute OUTPUT-PATH as the unique ID for the harvester."
  (declare (ignore model))
  (let* ((custom-id (namestring (truename output-path)))
         (json-line (jsown:to-json
                     `(:obj ("custom_id" . ,custom-id)
                            ("request" . (:obj ("contents" . ((:obj ("role" . "user")
                                                                   ("parts" . ((:obj ("text" . ,prompt-text)))))))
                                               ("generationConfig" . (:obj ("temperature" . 0.0)))))))))
    (if (and *batch-output-stream* (open-stream-p *batch-output-stream*))
        (progn
          (format *batch-output-stream* "~A~%" json-line)
          (finish-output *batch-output-stream*))
        (error "Batch output stream is not open. Bind *batch-output-stream* before running."))))

(defun run-chat-with-kw (&key
                           (gemini-model "gemini-2.5-pro")
                           (context "context.txt")
                           (save "")
						   (tag "kw")
                           (batch-mode nil)
                           (input-files nil)
                           (exit-on-error nil)
                           (single-shot nil)
                           (remaining-args nil))
  (with-open-log-files ((:thinking-log (format nil "~a-thinking.log"   tag) :hour)  
                        (:answer-log   (format nil "~a-the-answer.log" tag) :hour)
                        (:token-log    (format nil "~a-token.tkn"      tag) :ymd)
                        (:error-log    (format nil "~a-error.log"      tag) :hour))
	(let ((prompt-text (car remaining-args)))
      (if batch-mode
          (write-batch-jsonl-line prompt-text gemini-model save)
          ;; FIXED: Use the internal gem-conv/build-full-prompt logic 
          ;; instead of the undefined 'perform-live-gemini-chat'
		  ;; Inside run-chat-with-kw
		  (multiple-value-bind (assembled-prompt success-p blob-ids)
			  (build-full-prompt context input-files prompt-text exit-on-error)
			(if success-p
				;; Pass the blobs into gem-conv so they become real 'file_data' parts
				(gem-conv assembled-prompt save single-shot exit-on-error 
						  :model gemini-model 
						  :blob-ids blob-ids)
				(when exit-on-error 
				  (error "Failed to assemble prompt for ~A" save))))))))




