;;;; gemini-chat.lisp
;;;; -*- Mode: Lisp; indent-tabs-mode: nil -*-

(in-package #:gemini-chat)

(declaim (optimize (speed 0) (safety 3) (debug 3) (space 0)))

;; A default tag to use if none is provided on the command line.
(defparameter *d-tag* "chat")

;; New special variable for the runtime output file stream
(defparameter *run-out-s* nil
  "Stream for saving conversation answers during a conversation.")

;; Global for help formatting
(defparameter *help-column-width* 80)

;; Log file base name for xlg-lib
(defparameter *log-file-base* "gemini-chat-log"
  "Base name for the log files generated by xlg-lib.")

;; Function to retrieve the current version
(defun get-version ()
  (slot-value (asdf:find-system 'gemini-chat) 'asdf:version))

;; --- Define Flags using com.google.flag ---

(define-flag *keyname*
  :help "Name of gemini api key to retrieve"
  :type string
  :selector "key"
  :default-value "personal")

(define-flag *api-url*
  :help "URL for gemini api"
  :type string
  :selector "api-url"
  :default-value "https://generativelanguage.googleapis.com/v1beta/models/")

(define-flag *context*
  :help "Path to a context file. Can be specified multiple times. Example: --context file1.txt,file2.txt"
  :type list
  :parser string-identity-parser
  :selector "context"
  :default-value nil)

(define-flag *save*
  :help "File to save Gemini's responses to. Responses will be appended. Example: --save conversation.log"
  :type string
  :selector "save"
  :default-value "")

(define-flag *tag*
  :help "A unique tag for the conversation logs (default: chat). Example: --tag my-session"
  :type string
  :selector "tag"
  :default-value "chat")

(define-flag *input-files*
  :help "Comma-separated list of input files whose content will be sent with your prompt. Example: --input-files my-code.lisp,data.csv"
  :type list
  :parser string-identity-parser
  :selector "input-files"
  :default-value nil)

(define-flag *help-is*
  :help "Show this help message and exit."
  :type boolean
  :selector "help"
  :default-value nil)

(define-flag *single-shot*
  :help "Quit after first query completed"
  :type boolean
  :selector "single-shot"
  :default-value nil)

(define-flag *exit-on-error*
  :help "Exit the program immediately if an input file cannot be read."
  :type boolean
  :selector "exit-on-error"
  :default-value nil)

(defun get-key (&optional (key-name *keyname*))
  "Retrieves the Gemini API key from ~/.key/keys.lsp. If not found,
   we use the GEMINI_API_KEY environment variable.
   Signals an error if the environment variable is not set.
   It first tries GEMINI_API-KEY, then falls back to _GEMINI_API-KEY_."
  (let* ((fn "~/.gemini/keys.lsp")
         (keys (if (probe-file fn)
                   (uiop:read-file-form fn)
                   nil)))
    (let* ((keyv (cond ((eq (type-of *keyname*) :keyword)
                        *keyname*)
                       (t (intern (string-upcase key-name) :keyword))))
           (key (cond (keys
                       (second (assoc keyv keys)))
                      (t (format t "getting key from environment ~%")
                         (getenv "GEMINI_API_KEY")))))
      (unless key
        (error "Error: The GEMINI_API_KEY environment variable is not set.
              Please set this before running this program."))
      key)))

(defparameter *remaining-args* nil)

(defun string-identity-parser (s)
  "A parser function for com.google.flag that simply returns the string itself
   and a success boolean T. Used for list flags where each element is a string."
  (let ((full-l nil))
    (mapc #'(lambda (k)
              (push k full-l))
          (s-s s #\,))
    (values (reverse full-l) t)))

(defun s-s (str delim &key (rem-empty nil))
  "Encapsulates calls to split-sequence. Splits a string by a single character delimiter.
   :rem-empty T will remove empty strings from the result list."
  (split-sequence:split-sequence delim str :remove-empty-subseqs rem-empty))

(defun s/z (str)
  (zerop (length str)))

(defun s/nz (str)
  (plusp (length str)))

;; --- Primitives for Help Formatting ---

(defun get-sorted-flags ()
  "Retrieves and sorts the registered flags alphabetically by their selector string."
  (sort (copy-list com.google.flag::*registered-flags*)
        #'string< :key #'car))

(defun find-max-selector-length (flags)
  "Finds the maximum length of the flag selector strings for alignment."
  (let ((max-length 0))
    (dolist (flag-pair flags)
      (setf max-length (max max-length (length (car flag-pair)))))
    max-length))

(defun print-flag-help (selector flag max-selector-length)
  "Prints the help message for a single flag with proper padding using ~vt."
  (let* ((help-text (slot-value flag 'com.google.flag::help))
         (padding (+ max-selector-length 5))) ; 5 spaces to separate --selector and help text
    (format t "  --~a~vt~a~%"
            selector
            padding
            help-text)))

(defun print-help ()
  "Prints the command-line help message and example usage."
  (format t "~&gemini-chat version ~a~%~%" (get-version))
  (format t "Usage: ./gemini-chat [options] [initial_prompt]~%~%")
  (format t "Options:~%")

  (let* ((flags (get-sorted-flags))
         (max-selector-length (find-max-selector-length flags)))
    (dolist (flag-pair flags)
      (print-flag-help (car flag-pair) (cdr flag-pair) max-selector-length)))

  (format t "~%")
  (format t "Interactive Commands (during chat loop):~%")
  (format t "  :input <file1,file2,...>         Add file content to the next prompt.~%")
  (format t "  :save <filename>                 Start or change saving model responses to the specified file.~%")
  (format t "  quit                             End the conversation.~%~%")
  (format t "Initial Prompt:~%")
  (format t "~@<  If no initial prompt or input files are given, the program will prompt you interactively.~:>" *help-column-width*)
  (format t "~@<  Otherwise, all non-option arguments are treated as the initial prompt text.~:>" *help-column-width*)
  (format t "~%---~%~%")
  (format t "## Example Flow:~%~%")
  (format t "~@<To use the `gemini-chat` program with input files, a context file, a defined output file, and a prompt that references the input files, you'd use a command like this:~:>" *help-column-width*)
  (format t "~%```bash~%")
  (format t "./gemini-chat --context your_context.md --input-files code.lisp,tests.lisp --save session.log \"Based on the attached Lisp code and its tests, please suggest improvements.\"~%")
  (format t "```~%~%")
  (format t "~@<Let's break down the components of that command:~:>" *help-column-width*)
  (format t "~%* **`./gemini-chat`**: ~@<This is how you'd typically execute the compiled program.~:>" *help-column-width*)
  (format t "~%* **`--context your_context.md`**:~%")
  (format t "~@<  This flag specifies a **context file**. Its content is provided to the model for background information that should influence the response, but isn't the primary subject of your query.~:>" *help-column-width*)
  (format t "~%* **`--input-files code.lisp,tests.lisp`**:~%")
  (format t "~@<  This flag specifies one or more **input files**. The content of these files is included directly in your prompt, enclosed in markers. This is for content you want the model to directly analyze, modify, or reference.~:>" *help-column-width*)
  (format t "~%* **`--save session.log`**:~%")
  (format t "~@<  This flag tells `gemini-chat` to append all of the model's responses to the file `session.log`.~:>" *help-column-width*)
  (format t "~%* **`\"Based on the attached Lisp code...\"`**:~%")
  (format t "~@<  This is the **initial prompt**. It's the main instruction or question for the model. All non-option arguments are combined to form this prompt.~:>" *help-column-width*)
  (format t "~%---~%~%")
  (format t "### How the prompt is built:~%~%")
  (format t "~@<Internally, `gemini-chat` assembles these pieces into a single large prompt to send to the Gemini API. For the example above, the structure would look like this:~:>" *help-column-width*)
  (format t "~%```~%")
  (format t "--- Context Files --~%")
  (format t "File: your_context.md~%")
  (format t "```... content of your_context.md ...```~%")
  (format t "~%")
  (format t "--- End Context Files --~%")
  (format t "~%")
  (format t "===BEGIN_FILE: [code.lisp]===~%")
  (format t "... content of code.lisp ...~%")
  (format t "===END_FILE: [code.lisp]===~%")
  (format t "~%")
  (format t "===BEGIN_FILE: [tests.lisp]===~%")
  (format t "... content of tests.lisp ...~%")
  (format t "===END_FILE: [tests.lisp]===~%")
  (format t "~%")
  (format t "~@<My prompt: Based on the attached Lisp code and its tests, please suggest improvements.~:>" *help-column-width*)
  (format t "~%```~%~%")
  (format t "~@<This entire block of text is what gets sent to the model for the first turn of the conversation.~:>" *help-column-width*)
  (finish-output))


;; --- Primitives for JSOWN-specific data structure creation ---

(defun make-text-part (text)
  "Creates a Lisp :OBJ representing a 'part' in the Gemini API JSON structure."
  (jsown:new-js ("text" text)))

(defun make-content-object (parts)
  "Creates a Lisp :OBJ representing 'content' in the Gemini API JSON structure."
  (jsown:new-js ("parts" parts)))

(defun make-message-turn (role content-parts)
  "Creates a Lisp :OBJ representing a single 'turn' (message) in the Gemini API JSON structure.
   This will be encoded by JSOWN as a JSON object."
  (jsown:new-js
    ("role" role)
    ("parts" content-parts)))

(defun make-api-request-payload (msgs)
  "Constructs the full JSON payload object for the Gemini API."
  (jsown:new-js ("contents" msgs)))

(defun api-req (msgs &key (model "gemini-2.5-pro"))
  "Constructs and sends an HTTP POST request to the Gemini API.
   'msgs' should be a list of Lisp :OBJ structures, each representing a conversation turn.
   'model' specifies the Gemini model to use (e.g., \"gemini-2.5-pro\", \"gemini-1.5-flash\").
   Returns the response stream if successful."
  (let* ((api-key (get-key *keyname*))
         (api-url (format nil "~a~a:generateContent?key=~a" *api-url* model api-key))
         (json-payload-lisp-object (make-api-request-payload msgs))
         (json-payload-string (jsown:to-json json-payload-lisp-object))
         (headers '(("Content-Type" . "application/json"))))
    (xlg :thinking-log "~&Making API request to: ~a" api-url)
    (xlg :thinking-log "JSON string being sent: ~a" json-payload-string)
    (handler-case (drakma:http-request api-url :method :post :content-type "application/json" :content json-payload-string :additional-headers headers :want-stream t :force-ssl t)
      (drakma:drakma-error (c)
        (error "HTTP Request Failed: ~a" c))
      (error (c)
        (error "An unexpected error occurred during the HTTP request: ~a" c)))))

(defun parse-api-resp (resp-stream)
  "Parses the JSON response from the Gemini API response stream using jsown.
   Returns the parsed JSON as a Lisp object (jsown's internal :OBJ format)."
  (handler-case
      (let* ((json-string (uiop:slurp-stream-string resp-stream))
             (pjs (jsown:parse json-string)))
        (xlg :thinking-log "~&Raw JSON string received:~% ~a" pjs)
        pjs)
    (error (c)
      (xlg :error-log "~&Failed to parse JSON response: ~a" c)
      (error "Failed to parse JSON response: ~a" c))))

(defun extract-txt (parsed-json)
  "Extracts the generated text from the parsed Gemini API JSON response using jsown accessors. Returns the text string or NIL if not found."
  (cond ((jsown:keyp parsed-json "error")
         (progn
           (xlg :thinking-log "~&API returned an error: ~a" (jsown:val parsed-json "error"))
           (xlg :answer-log "~&API returned an error: ~a" (jsown:val parsed-json "error"))
           nil))
        ((jsown:keyp parsed-json "candidates")
         (let* ((candidates (jsown:val parsed-json "candidates"))
                (first-candidate (car candidates))
                (content (jsown:val first-candidate "content"))
                (parts (jsown:val content "parts"))
                (first-part (car parts))
                (text (jsown:val first-part "text")))
           (xlg :answer-log "~&Raw answer: ~a" text)
           (setf text (string-trim '(#\Space #\Tab #\Newline) text))
           (format t "~%~a~%" text)
           (if *run-out-s*
               (format *run-out-s* "~a~%" text))
           text))
        (t
         (xlg :error-log "~&Unexpected API response format: ~a" parsed-json)
         (error "Unexpected API response format."))))

;; --- Primitives for Prompt Assembly ---

(defun assemble-context-prompt (ctx-content)
  "Assembles the context section of the prompt."
  (when (s/nz ctx-content)
    (format nil "--- Context Files --~%~a~%--- End Context Files --~%" ctx-content)))

(defun assemble-input-files-prompt (input-files)
  "Reads and assembles the content of input files into a prompt section."
  ;; TODO use file-packer. Also make public file-packer github
  (let ((prompt-list nil)
        (all-files-read-ok t))
    (when input-files
      (dolist (file-path input-files)
        (if (uiop:file-exists-p file-path)
            (let ((file-content (uiop:read-file-string file-path)))
              (push (format nil "===BEGIN_FILE: [~a]===~%~a~%===END_FILE: [~a]==="
                            (file-namestring file-path)
                            file-content
                            (file-namestring file-path))
                    prompt-list))
            (progn
              (setf all-files-read-ok nil)
              (xlg :error-log "~&Failed to read input file: ~a" file-path)
              (format t "~&Failed to read input file: ~a~%" file-path)
              (if *exit-on-error*
                  (return-from assemble-input-files-prompt (values nil nil)))))))
    (values (format nil "~{~a~%~%~}" (nreverse prompt-list)) all-files-read-ok)))

(defun assemble-user-prompt (prompt)
  "Formats the user's initial prompt."
  (when (s/nz prompt)
    (format nil "My prompt: ~a" prompt)))

(defun build-full-prompt (ctx-content input-files prompt)
  "Constructs the complete prompt by combining all sections."
  (let ((full-prompt-list nil))
    (multiple-value-bind (input-files-string success-p) (assemble-input-files-prompt input-files)
      (unless success-p
        (return-from build-full-prompt (values nil nil)))
      (when ctx-content
        (push (assemble-context-prompt ctx-content) full-prompt-list))
      (when input-files-string
        (push input-files-string full-prompt-list))
      (when prompt
        (push (assemble-user-prompt prompt) full-prompt-list))
      (let ((assembled-prompt (format nil "~{~a~%~%~}" (nreverse full-prompt-list))))
        (xlg :thinking-log "~&Full assembled prompt for Gemini:~%~a~%" assembled-prompt)
        (values assembled-prompt t)))))

(defun gem-conv (initial-prompt &key (model "gemini-2.5-pro"))
  "Handles a single conversation turn with Gemini. 'initial-prompt' is the first message."
  (let ((conversation-history (list (make-message-turn "user" (list (make-text-part initial-prompt))))))
    (loop
      (handler-case
          (let* ((resp-stream (api-req conversation-history :model model))
                 (parsed-json (parse-api-resp resp-stream)))
            (close resp-stream)
            (when *save*
                (save-cmd (format nil ":save ~a" *save*)))
            (let ((answer (extract-txt parsed-json)))
              (when (jsown:keyp parsed-json "candidates")
                (push (make-message-turn "model" (list (make-text-part answer))) conversation-history))
              (unless (or (string= answer "quit") (string= answer ":quit") *single-shot*)
                (format t "~&Single shot is ~s>> " *single-shot*)
                (finish-output)
                (let ((user-input (read-line)))
                  (when (or (string= user-input "quit") (string= user-input ":quit"))
                    (return))
                  (let ((command (if (s/nz user-input)
                                     (string-trim '(#\Space #\Tab)
                                                  (car (s-s user-input #\Space :rem-empty nil)))
                                     "")))
                    (cond
                      ((string= command ":input")
                       (input-cmd user-input))

					  ((string= command ":save")
                       (save-cmd user-input)) ;; TODO--wrong

                      (t
                       (push (make-message-turn "user" (list (make-text-part user-input))) conversation-history)))))))
            (when *single-shot* (return)))
        (error (e)
          (xlg :error-log "~&An error occurred: ~a~%" e)
          (format t "~&An error occurred: ~a~%~%" e)
          (when *exit-on-error*
            (return)))))))

(defun save-cmd (out-to-user &key (if-exists :supersede))
  "Handles the :save command, opening a new file for responses."
  (let* ((args (s-s out-to-user #\Space :rem-empty t))
         (file-path (second args)))
    (when (s/z file-path)
      (format t "~&Please specify a file to save to, e.g., :save my-session.log~%")
      (return-from save-cmd))
    (when *run-out-s*
      (format t "~&Closing previous save file: ~a~%" (file-namestring (pathname *run-out-s*)))
      (close *run-out-s*)
      (setf *run-out-s* nil))
    (handler-case
        (let ((actual-path (if (uiop:absolute-pathname-p file-path)
                               file-path
                               (uiop:merge-pathnames* file-path (uiop:getcwd)))))
          (xlg :thinking-log "~&Opening save file: ~a" actual-path)
          (setf *run-out-s* (open actual-path :direction :output :if-does-not-exist :create :if-exists if-exists))
          (format t "~&Now saving responses to: ~a~%" actual-path))
      (error (c)
        (xlg :error-log "~&Failed to open file for saving: ~a" c)
        (format t "~&Failed to open file for saving: ~a~%" c)
        (setf *run-out-s* nil)))))

(defun input-cmd (user-input)
  "Handles the :input command. Currently just logs the intention."
  (let* ((args (s-s user-input #\Space :rem-empty t))
         (files (second args)))
    (when (s/z files)
      (format t "~&Please specify input files, e.g., :input file1.txt,file2.lisp~%")
      (return-from input-cmd))
    (format t "~&[Note: Input files functionality is part of the initial prompt only in this version. Files will be included in the next request, but not in interactive mode as of yet]~%")))

(defun get-default-context-file ()
  "Returns the path to the default context file if it exists."
  (let ((default-path (uiop:merge-pathnames* "gemini-chat-context.md" (uiop:getcwd))))
    (if (uiop:file-exists-p default-path)
        default-path
        nil)))

(defun proc-ctx-files (file-list)
  "Processes a list of context files and returns a single string of their combined content."
  (when file-list
    (let ((result (make-string-output-stream)))
      (dolist (file file-list)
        (handler-case
            (format result "~&File: ~a~%```~%~a~%```~%~%" (file-namestring file) (uiop:read-file-string file))
          (error (e)
            (xlg :error-log "~&Failed to read context file: ~a" e)
            (format t "~&Failed to read context file: ~a~%" e))))
      (get-output-stream-string result))))

(defun show-opts (&key (bad-args nil))
  "Prints the command-line options to the thinking log file, using the flag special variables."
  (xlg :option-log "~&Entering run-chat with flags:" )
  (xlg :option-log "Keyname: ~a" *keyname*)
  (xlg :option-log "Context files: ~a" *context*)
  (xlg :option-log "Save file: ~a" *save*)
  (xlg :option-log "Tag: ~a" *tag*)
  (xlg :option-log "Input files: ~a" *input-files*)
  (xlg :option-log "Help requested: ~a" *help-is*)
  (xlg :option-log "Single shot: ~a" *single-shot*)
  (xlg :option-log "Exit on error: ~a" *exit-on-error*)
  (xlg :option-log "Using model: ~a" "gemini-2.5-pro") ; Model is currently hardcoded in run-chat
  (xlg :option-log "Remaining args: ~a" *remaining-args*)
  (when bad-args
    (xlg :option-log "Unprocessed command-line options: ~s" bad-args)))

(defun chk-args (args)
  (let ((remaining-args (parse-command-line args)))
	(setf *remaining-args* remaining-args)
	(let ((badargs (loop for m in *remaining-args*
                         when (and (plusp (length m))
                                   (char= (char m 0) #\-))
                           collect m)))
      (show-opts :bad-args badargs)
      (when badargs
        (error "Unprocessed command-line options: ~s" badargs)
		#+hil (return-from chk-args nil))
	  (get-key *keyname*))
	(cond (*help-is*
		   (print-help)
		   nil)
		  (t t))))

(defun run-chat (args &key (model "gemini-2.5-pro"))
  "Main function to run the chat loop. 'args' is the list of command-line arguments. Answer true if appears successful"
  #+nil (break "start run")
  (with-open-log-files ((:option-log "option-log" :ymd))
    (unless (chk-args args)
	  (return-from run-chat)))
  
  (let* ((input-files *input-files*)
         (context-files *context*)
         (tag *tag*)
         (prompt (string-trim '(#\Space #\Tab #\Newline) (format nil "~{~a~^ ~}" *remaining-args*))))

	(with-open-log-files ((:thinking-log (format nil "~a-thinking.log" tag) :ymd)
                          (:answer-log (format nil "~a-the-answer.log" tag) :ymd)
                          (:error-log (format nil "~a-error.log" tag) :ymd))
      (let* ((actual-context-files (if context-files
                                       context-files
                                       (let ((default-ctx (get-default-context-file)))
                                         (if default-ctx (list default-ctx) nil))))
             (ctx-content (proc-ctx-files actual-context-files)))
        (when (or (s/nz prompt) input-files context-files)
          (multiple-value-bind (assembled-prompt success-p)
              (build-full-prompt ctx-content input-files prompt)
            (unless success-p
              (format t "~&Failed to assemble initial prompt. Exiting.~%")
              (return-from run-chat nil))
            (unwind-protect
                 (progn
                   (format t "~&Sending request to Gemini...~%")
                   (gem-conv assembled-prompt :model model))
              ;; Ensure output stream is closed on exit
              (when *run-out-s*
                (format t "~&Closing save file: ~a~%" (file-namestring (pathname *run-out-s*)))
                (close *run-out-s*)
                (setf *run-out-s* nil)))))
        (format t "~&Exiting.~%")))))

(defun slime-chat (&key (input-files nil) (context-files nil) (save-file nil) (tag *d-tag*) (model "gemini-2.5-pro") (prompt "") (exit-on-error nil) (keyname "personal"))
  "Starts a chat session from SLIME with the provided options."
  (let ((*input-files* input-files)
        (*context* context-files)
        (*save* save-file)
        (*tag* tag)
        (*keyname* keyname)
        (*single-shot* nil)
        (*exit-on-error* exit-on-error))

    (with-open-log-files ((:thinking-log (format nil "~a-thinking.log" *tag*) :ymd)
                          (:answer-log (format nil "~a-the-answer.log" *tag*) :ymd)
                          (:error-log (format nil "~a-error.log" *tag*) :ymd))
      (xlg :thinking-log "~&Entering SLIME chat with args: ~s" (list :input-files input-files :context-files context-files :save-file save-file :tag *tag* :model model :prompt prompt))

      (let* ((actual-context-files (if context-files
                                     context-files
                                     (let ((default-ctx (get-default-context-file)))
                                       (if default-ctx (list default-ctx) nil))))
           (ctx-content (proc-ctx-files actual-context-files)))
        (format t "~&Starting SLIME chat session...~%")
        (format t "~&Prompt: ~a~%~%" prompt)
        (when input-files (format t "~&Input Files: ~a~%~%" input-files))
        (when actual-context-files (format t "~&Context Files: ~a~%~%" actual-context-files))
        (when save-file (format t "~&Save File: ~a~%~%" save-file))
        (format t "~&Model: ~a~%~%" model)
        (format t "~&Tag: ~a~%~%" *tag*)

        ;; Initialize *run-out-s* if a save-file is provided
        (when save-file
          (save-cmd (format nil ":save ~a" save-file) :if-exists :append)) ; Explicitly append

        (multiple-value-bind (assembled-prompt success-p)
            (build-full-prompt ctx-content input-files prompt)
          (unless success-p
            (format t "~&Failed to assemble initial prompt. Exiting SLIME chat.~%")
            (return-from slime-chat nil))

          (unwind-protect
               (progn
                 (format t "~&Sending request to Gemini...~%")
                 (gem-conv assembled-prompt :model model))
            ;; Ensure output stream is closed on exit
            (when *run-out-s*
              (format t "~&Closing save file: ~a~%" (file-namestring (pathname *run-out-s*)))
              (close *run-out-s*)
              (setf *run-out-s* nil))))))))

(defun top ()
  "Toplevel function for the compiled gemini-chat executable.
   It retrieves arguments from sb-ext:*posix-argv* and passes them to run-chat."
  ;; com.google.flag:parse-command-line without :argv defaults to sb-ext:*posix-argv*
  ;; However, run-chat expects a list of strings, so pass (rest sb-ext:*posix-argv*)
  (format t "~&Top: we have command line args of ~%~s~%~%" sb-ext:*posix-argv*)
  (run-chat (rest sb-ext:*posix-argv*)))

(defun save-core-uncompressed ()
  "Saves the current Lisp image as an uncompressed executable for faster development."
  (format t "~&Building gemini-chat version ~a (uncompressed)~%~%" (get-version))
  (sb-ext:save-lisp-and-die "gemini-chat"
                            :toplevel #'top
                            :save-runtime-options t
                            :executable t))

(defun save-core ()
  "Saves the current Lisp image as an executable."
  (format t "~&Building gemini-chat version ~a~%~%" (get-version))
  (sb-ext:save-lisp-and-die "gemini-chat"
                            :toplevel #'top
                            :save-runtime-options t
                            :executable t
                            :compression t))
